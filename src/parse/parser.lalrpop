use crate::parse::ast;

use crate::translate;

grammar(context: &mut translate::Context);


match {
    // Do not allow "true" or "false" as identifiers. Make them literals.
    r"(true)|(false)" => BOOL,
    // Ignore comments
    // from https://github.com/lalrpop/lalrpop/pull/509/commits/ee2f7060e99f902620ac4edeea5cfe3c3551f09c)
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { },
    // TODO: Look at this regex; it may do more than I want 
    // TODO: Inline comments don't work
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
} else {
    _
}


// ---------------- AST ----------------

// This is the root of the AST (initial grammar symbol)
pub AST: ast::AST = {
    Item* => <>,
}

// An AST is composed of Items
Item: ast::Item = {
    Function => <>,
    Scene => <>,
    Struct => <>,
}

// ---------------- SCENE ----------------

Scene: ast::Item = {
    "scene" <name:Ident> <s:StatementBlock> => ast::Item::Scene{name: name, statements: s},
}

// ---------------- FUNCTION ----------------

Function: ast::Item = {
    "fn" <name:Ident> <params:FunctionParams> <return_type:("->" <Ident>)?> <s:StatementBlock> 
    => {
        let ret = if let Some(ty) = return_type {
            ty 
        } else {
            "void".to_owned()
        };

        context.declare_function(name.clone(), params.clone(), ret.clone());

        ast::Item::Function {
            name,
            parameters: params,
            return_type: ret,
            statements: s,
        }
    },
}

#[inline]
FunctionParams: Vec<(String, String)> = {
    "(" <multi:(<Ident> ":" <Ident> ",")*> 
        <single:(<Ident> ":" <Ident>)?> ")" 
    => {
        let mut params = multi;
        
        if let Some(param) = single {
            params.push(param);
        }

        params
    },
}

// ---------------- STRUCT ----------------

Struct: ast::Item = {
    "struct" <name:Ident> "{" <fields:(StructFields)> "}" => {
        context.declare_struct(name.clone(), fields.clone());
        
        ast::Item::Struct {
            name,
            fields,
        }
    },
}

// TODO: Support more than just literals as defaults
#[inline]
StructFields: Vec<(String, String, Option<ast::Literal>)> = {
    <multi:(<Ident> ":" <Ident> <("=" <Literal>)?> ",")*> 
    <single:(<Ident> ":" <Ident> <("=" <Literal>)?>)?> => {
        let mut fields = multi;
        
        if let Some(field) = single {
            fields.push(field);
        }

        fields
    }
}

// ---------------- STATEMENT ----------------

Statement: ast::Statement = {
    LetStatement => <>,
    <Expression> ";" => ast::Statement::Expression(<>),
}

StatementBlock: Vec<ast::Statement> = {
    "{" <statements:(Statement)*> "}" => {
        statements
    },
}
    
// FIXME: Separating out `Constructor` as "Ident { ConstructorArgs }" causes ambiguities
LetStatement: ast::Statement = {
    // TODO: Allow non-assigning declarations
    // let x = 7;
    <tag:("@" <Tag>)?>
    "let" <id:Ident> <ty: (":" <Ident>)?> "=" <expr:Expression> ";" => ast::Statement::Let {
        ident: id.to_owned(),
        tag,
        ty,
        expression: Some(expr),
    },

    // let identifier: type { param1: value1, param2: value2, ...};
    "let" <id:Ident> ":" <ty:Ident> "{" <fields:(ConstructorArgs)> "}" ";" => ast::Statement::LetConstructor {
        ident: id.to_owned(),
        constructor: ast::Constructor {
            ty: ty,
            fields,
        },
    },

    "return" <expr:(Expression)?> ";" => ast::Statement::Return {
        expression: expr,
    },
}

ConstructorArgs: Vec<(String, ast::Expression)> = {
    <multi:(<Ident> ":" <Expression> ",")*>
    <single:(<Ident> ":" <Expression>)?> => {
        let mut args = multi;
        
        if let Some(arg) = single {
            args.push(arg);
        }

        args
    },
}

// ---------------- EXPRESSION ----------------

// FIXME: Understand how precedence works
Expression: ast::Expression = {
    BooleanExpr => <>,
}

// Treated same as identifier/literal
FunctionCall: ast::Expression = {
    <name:Ident> "(" <params_multi:(<Expression> ",")*>
                     <param_final:(<Expression>)?> ")"
    => {
        let mut params = params_multi;
        if let Some(param) = param_final {
            params.push(param);
        }

        ast::Expression::FunctionCall {
            name,
            parameters: params,
        }
    }
}

// Fourth precedence - left associativity
BooleanExpr: ast::Expression = {
    <lhs:BooleanExpr> <op:BoolOp> <rhs:AdditiveExpr> => ast::Expression::Binary {
        lhs: Box::new(lhs),
        operator: op,
        rhs: Box::new(rhs),
    },

    AdditiveExpr => <>,
}

// Third precedence - left associativity
AdditiveExpr: ast::Expression = {
    <lhs:AdditiveExpr> <op:AddOp> <rhs:MultiplicativeExpr> => ast::Expression::Binary {
        lhs: Box::new(lhs),
        operator: op,
        rhs: Box::new(rhs),
    },

    MultiplicativeExpr => <>,
}

// Second precedence - left associativity
MultiplicativeExpr: ast::Expression = {
    <lhs:MultiplicativeExpr> <op:MultOp> <rhs:BaseExpr> => {
        ast::Expression::Binary {
            lhs: Box::new(lhs),
            operator: op,
            rhs: Box::new(rhs),
        }
    },

    BaseExpr => <>,
}

// First precedence - right associativity (for unary ops)
BaseExpr: ast::Expression = {
    "(" <Expression> ")" => <>,

    Literal => ast::Expression::Literal(<>),

    Ident => ast::Expression::Identifier(<>),

    FunctionCall => <>,

    "-" <BaseExpr> => ast::Expression::Unary {
        operator: ast::UnaryOperator::Negate,
        rhs: Box::new(<>),
    },

    "!" <BaseExpr> => ast::Expression::Unary {
        operator: ast::UnaryOperator::Not,
        rhs: Box::new(<>),
    },
}

#[inline]
AssignmentOperator: ast::AssignmentOperator = {
    "=" => ast::AssignmentOperator::Assign,
    "+=" => ast::AssignmentOperator::AddAssign,
    "-=" => ast::AssignmentOperator::SubtractAssign,
    "*=" => ast::AssignmentOperator::MultiplyAssign,
    "/=" => ast::AssignmentOperator::DivideAssign,
}

#[inline]
MultOp: ast::BinaryOperator = {
    "*" => ast::BinaryOperator::Multiply,
    "/" => ast::BinaryOperator::Divide,
}

#[inline]
AddOp: ast::BinaryOperator = {
    "+" => ast::BinaryOperator::Plus,
    "-" => ast::BinaryOperator::Minus,
}

#[inline]
BoolOp: ast::BinaryOperator = {
    "==" => ast::BinaryOperator::EqualTo,
    "!=" => ast::BinaryOperator::NotEqualTo,
    ">=" => ast::BinaryOperator::GreaterThanOrEqualTo,
    "<=" => ast::BinaryOperator::LessThanOrEqualTo,
    ">" => ast::BinaryOperator::GreaterThan,
    "<" => ast::BinaryOperator::LessThan,
    "&&" => ast::BinaryOperator::And,
    "||" => ast::BinaryOperator::Or,
}

// ---------------- IDENTIFIER, LITERAL, TAG ----------------

Ident: String = {
    <r"[_a-zA-Z]+[_a-zA-Z0-9]*"> => <>.to_owned(),
}

#[inline]
Tag: ast::Tag = {
    "uniform" => ast::Tag::Uniform,
    "texture2D" => ast::Tag::Texture2D,
}

Literal: ast::Literal = {
    <uint:r"[0-9]+"> => ast::Literal::UInt(uint.parse::<u32>().unwrap()),
    <float:r"[0-9]+[.][0-9]*"> => ast::Literal::Float(float.parse::<f32>().unwrap()),
    <boolean:BOOL> => ast::Literal::Bool(boolean.parse::<bool>().unwrap()),
}