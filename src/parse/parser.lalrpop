use crate::parse::ast;

grammar;


match {
    // Do not allow "true" or "false" as identifiers. Make them literals.
    r"(true)|(false)" => BOOL,
    // Ignore comments
    // from https://github.com/lalrpop/lalrpop/pull/509/commits/ee2f7060e99f902620ac4edeea5cfe3c3551f09c)
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { },
    // TODO: Look at this regex; it may do more than I want 
    // TODO: Inline comments don't work
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
} else {
    _
}


// ---------------- AST ----------------

// This is the root of the AST (initial grammar symbol)
pub AST: ast::AST = {
    Item* => <>,
}

// An AST is composed of Items
Item: ast::Item = {
    Function => <>,
    Scene => <>,
    Struct => <>,
}

// ---------------- SCENE ----------------

Scene: ast::Item = {
    "scene" <name:Ident> <s:StatementBlock> => ast::Item::Scene{name: name, statements: s},
}

// ---------------- FUNCTION ----------------

Function: ast::Item = {
    "fn" <name:Ident> <params:FunctionParams> <return_type:("->" <Ident>)?> <s:StatementBlock> 
    => ast::Item::Function {
        parameters: params,
        return_type,
        statements: s,
    },
}

#[inline]
FunctionParams: Vec<(String, String)> = {
    "(" <multi:(<Ident> ":" <Ident> ",")*> <single:(<Ident> ":" <Ident>)?> ")" => {
        let mut params = multi;
        
        if let Some(param) = single {
            params.push(param);
        }

        params
    },
}

// ---------------- STRUCT ----------------

Struct: ast::Item = {
    "struct" <id:Ident> "{" <fields:(StructField)+> "}" => ast::Item::Struct {
        name: id,
        fields,
    },
}

// TODO: What would be valid defaults?
// TODO: Make final comma optional
#[inline]
StructField: (String, String, Option<ast::Expression>) = {
    <id:Ident> ":" <ty:Ident> <def:("=" <Expression>)?> "," => (id, ty, def),
}

// ---------------- STATEMENT ----------------

pub Statement: ast::Statement = {
    LetStatement => <>,
    <Expression> ";" => ast::Statement::Expression(<>),
}

StatementBlock: Vec<ast::Statement> = {
    "{" <statements:(Statement)*> "}" => {
        statements
    },
}
    
// FIXME: Separating out `Constructor` as "Ident { ConstructorArgs }" causes ambiguities
LetStatement: ast::Statement = {
    // TODO: Allow non-assigning declarations
    // let x = 7;
    "let" <id:Ident> <ty: (":" <Ident>)?> "=" <expr:Expression> ";" => ast::Statement::Let {
        ident: id.to_owned(),
        ty,
        expression: Some(expr),
    },

    // let identifier: type { param1: value1, param2: value2, ...};
    "let" <id:Ident> ":" <ty:Ident> "{" <fields:(ConstructorArgs)> "}" ";" => ast::Statement::LetConstructor {
        ident: id.to_owned(),
        constructor: ast::Constructor {
            ty: ty,
            fields,
        },
    },
}

// TODO: Make final comma optional
ConstructorArgs: Vec<(String, ast::Expression)> = {
    <pair:(<Ident> ":" <Expression> ",")*> => pair,
}

// ---------------- EXPRESSION ----------------

Expression: ast::Expression = {
    Literal => ast::Expression::Literal(<>),
    Ident => ast::Expression::Identifier(<>),
    // BinaryExpression => <>,
}

// TODO: Add precedence and associativity to remove the local ambiguity here
BinaryExpression: ast::Expression = {
    <l:Expression> <op:BinaryOperator> <r:Expression> => ast::Expression::Binary {
        lhs: Box::new(l),
        operator: op,
        rhs: Box::new(r),
    },
}

AssignmentOperator: ast::AssignmentOperator = {
    "=" => ast::AssignmentOperator::Assign,
}

BinaryOperator: ast::BinaryOperator = {
    "+" => ast::BinaryOperator::Plus,
    "-" => ast::BinaryOperator::Minus,
}

// ---------------- IDENTIFIER & LITERAL ----------------

Ident: String = {
    <r"[_a-zA-Z]+[_a-zA-Z0-9]*"> => <>.to_owned(),
}

Literal: ast::Literal = {
    <uint:r"[0-9]+"> => ast::Literal::UInt(uint.parse::<u32>().unwrap()),
    <float:r"[0-9]+[.][0-9]*"> => ast::Literal::Float(float.parse::<f32>().unwrap()),
    <boolean:BOOL> => ast::Literal::Bool(boolean.parse::<bool>().unwrap()),
}