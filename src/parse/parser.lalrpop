use crate::parse::{context::Context, ast};
use crate::exit_with_message;

grammar();


match {
    // Do not allow "true" or "false" as identifiers. Make them literals.
    r"(true)|(false)" => BOOL,
    r"[a-z]?(vec)[1-4]" => VEC_IDENTIFIER,

    // Ignore comments
    // from https://github.com/lalrpop/lalrpop/pull/509/commits/ee2f7060e99f902620ac4edeea5cfe3c3551f09c)
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { },
    // TODO: Look at this regex; it may do more than I want/need 
    // FIXME: In-line comments don't work
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
} else {
    _
}


// ---------------- AST ----------------

// This is the root of the AST (initial grammar symbol)
pub AST: ast::AST = {
    Item* => <>,
}

// TODO: Allow global let statements
// An AST is composed of Items
Item: ast::Item = {
    Function => <>,
    Implementation => <>,
    Scene => <>,
    Struct => <>,
}

// ---------------- SCENE ----------------

Scene: ast::Item = {
    "scene" <name:Ident> <s:StatementBlock> => ast::Item::Scene{name: name, statements: s},
}

// ---------------- FUNCTION ----------------

Implementation: ast::Item = {
    "impl" <id:Ident> "{" <functions:Function*> "}" => {
        if functions.len() == 0 {
            exit_with_message(format!("Error: To implement '{}', at least one function is needed", &id));
        }

        ast::Item::Implementation {
            struct_name: id,
            functions,
        }
    }
}

Function: ast::Item = {
    "fn" <name:Ident> <params:FunctionParams> <return_type:("->" <Ident>)?> <s:StatementBlock> 
    => {
        let ret = if let Some(ty) = return_type {
            ty 
        } else {
            "void".to_owned()
        };

        ast::Item::Function {
            name,
            parameters: params,
            return_type: ret,
            statements: s,
        }
    },
}

#[inline]
FunctionParams: Vec<(String, String)> = {
    "(" <self_single:(Ident)?>
        <self_comma:(<Ident> ",")?>
        <multi:(<Ident> ":" <Ident> ",")*> 
        <single:(<Ident> ":" <Ident>)?> ")" 
    => {
        let mut params = Vec::new();
        
        // FIXME: This whole thing is ugly, but it works
        if let Some(s) = self_single {
            if s != "self" {
                exit_with_message(format!("Error: TODO: not 'self'"));
            }
            params.push(("self".to_owned(), "self".to_owned())); 
        } else if let Some(sc) = self_comma {
            if sc != "self" {
                exit_with_message(format!("Error: TODO: not 'self'"));
            }
            params.push(("self".to_owned(), "self".to_owned())); 
        }

        params.extend_from_slice(&multi[0..]);
        
        if let Some(param) = single {
            params.push(param);
        }

        params
    },
}

// ---------------- STRUCT ----------------

Struct: ast::Item = {
    "struct" <name:Ident> "{" <fields:(StructFields)> "}" => {       
        ast::Item::Struct {
            name,
            fields,
        }
    },
}

#[inline]
StructFields: Vec<(String, String, Option<ast::Expression>)> = {
    <multi:(<Ident> ":" <Ident> <("=" <Expression>)?> ",")*> 
    <single:(<Ident> ":" <Ident> <("=" <Expression>)?>)?> => {
        let mut fields = multi;
        
        if let Some(field) = single {
            fields.push(field);
        }

        fields
    }
}

// ---------------- STATEMENT ----------------

Statement: ast::Statement = {
    LetStatement => <>,
    
    // TODO: Type check with owning function
    "return" <expr:(Expression)?> ";" => {
        ast::Statement::Return {
            expression: expr,
        }
    },

    AssignmentStatement => <>,

    ForLoop => <>,

    WhileLoop => <>,

    <LoopControl> ";" => <>,

    <Expression> ";" => ast::Statement::Expression(<>),
    
    <IfExpr> => ast::Statement::Expression(<>),
}

#[inline]
LoopControl: ast::Statement = {
    "continue" => ast::Statement::Continue,
    "break" => ast::Statement::Break,
}

// TODO: Allow expressions to define the range
ForLoop: ast::Statement = {
    "for" <id:Ident> "in" <from:Expression> ".." <to:Expression> <block:StatementBlock> => {
        ast::Statement::For {
            loop_var: id,
            from,
            to,
            block,
        }
    },
}

WhileLoop: ast::Statement = {
    "while" <cond:Expression> <statements:StatementBlock> => {
        ast::Statement::While {
            condition: cond,
            block: statements,
        }
    }
}

StatementBlock: Vec<ast::Statement> = {
    "{" <statements:(Statement)*> "}" => {
        statements
    },
}

// TODO: Separate out 'member' stuff rather than hacking in an expression lhs
AssignmentStatement: ast::Statement = {
    <lhs:Expression> <op:AssignmentOperator> <expr:Expression> ";" => {
        ast::Statement::Assignment {
            lhs,
            op,
            expression: expr,
        }
    }
}
    
LetStatement: ast::Statement = {
    <tag:("@" <Tag>)?>
    "let" <id:Ident> <ty: (":" <Ident>)?> <expr:("=" <Expression>)?> ";" => { 
        if ty.is_none() && expr.is_none() {
            exit_with_message(format!("Error: Standalone let statements like 'let {};' are not yet implemented", &id));
        }
        
        ast::Statement::Let {
            ident: id.to_owned(),
            tag,
            ty,
            expression: expr,
        }
    },

    // let identifier: type { param1: value1, param2: value2, ...};
    "let" <id:Ident> ":" <ty:Ident> "{" <fields:(ConstructorArgs)> "}" ";" => {        
        ast::Statement::LetConstructor {
            ident: id.to_owned(),
            constructor: ast::Constructor {
                ty: ty.clone(),
                fields,
            },
        }
    },
}

ConstructorArgs: Vec<(String, ast::Expression)> = {
    <multi:(<Ident> ":" <Expression> ",")*>
    <single:(<Ident> ":" <Expression>)?> => {
        let mut args = multi;
        
        if let Some(arg) = single {
            args.push(arg);
        }

        args
    },
}

// ---------------- EXPRESSION ----------------

Expression: ast::Expression = {
    BooleanExpr => <>,
}

// Treated same as identifier/literal
FunctionCall: ast::Expression = {
    <name:Ident> "(" <params_multi:(<Expression> ",")*>
                     <param_final:(<Expression>)?> ")"
    => {
        let mut params = params_multi;
        if let Some(param) = param_final {
            params.push(param);
        }

        ast::Expression::FunctionCall {
            name,
            parameters: params,
            ty: "temp".to_owned(),
        }
    }
}

IfExpr: ast::Expression = {
    // if .. else ..
    "if" <expr:BooleanExpr> <statements:StatementBlock> 
    <else_block:("else" <StatementBlock>)?>
    => {
        ast::Expression::If {
            expression: Box::new(expr),
            if_block: statements,
            else_block,
            else_if_block: None,
            ty: "temp".to_owned(),
        }
    },

    // if .. else if ..
    "if" <expr:BooleanExpr> <statements:StatementBlock> 
    <else_if_block:("else" <IfExpr>)>
    => {
        ast::Expression::If {
            expression: Box::new(expr),
            if_block: statements,
            else_block: None,
            else_if_block: Some(Box::new(else_if_block)),
            ty: "temp".to_owned(),
        }
    },
}

// Fifth precedence - left associativity
// Note that `BooleanExpr`s are always of type "bool" 
BooleanExpr: ast::Expression = {
    // TODO: Create more precedences: https://en.cppreference.com/w/cpp/language/operator_precedence
    <lhs:BooleanExpr> <op:BoolOp> <rhs:AdditiveExpr> => ast::Expression::Binary {
        lhs: Box::new(lhs),
        operator: op,
        rhs: Box::new(rhs),
        ty: "bool".to_owned(),
    },

    AdditiveExpr => <>,
}

// Fourth precedence - left associativity
AdditiveExpr: ast::Expression = {
    <lhs:AdditiveExpr> <op:AddOp> <rhs:MultiplicativeExpr> => {
        ast::Expression::Binary {
            lhs: Box::new(lhs),
            operator: op,
            rhs: Box::new(rhs),
            ty: "temp".to_owned(),
        }
    },

    MultiplicativeExpr => <>,
}

// Third precedence - left associativity
MultiplicativeExpr: ast::Expression = {
    <lhs:MultiplicativeExpr> <op:MultOp> <rhs:CastExpr> => {
        ast::Expression::Binary {
            lhs: Box::new(lhs),
            operator: op,
            rhs: Box::new(rhs),
            ty: "temp".to_owned(),
        }
    },

    CastExpr => <>,
}

// Second precedence - left associativity
CastExpr: ast::Expression = {
    <lhs:CastExpr> <op:CastOp> <rhs:BaseExpr> => {
        ast::Expression::Binary {
            lhs: Box::new(lhs),
            operator: op,
            rhs: Box::new(rhs),
            ty: "temp".to_owned(),
        }
    },

    BaseExpr => <>,
}

// TODO: Keep parenthesis around expressions when translating
// First precedence - right associativity (for unary ops)
BaseExpr: ast::Expression = {
    "(" <Expression> ")" => <>,

    Literal => ast::Expression::Literal(<>),

    Ident => {
        ast::Expression::Identifier(<>)
    },

    FunctionCall => <>,

    "-" <BaseExpr> => {
        ast::Expression::Unary {
            operator: ast::UnaryOperator::Negate,
            rhs: Box::new(<>),
            ty: "temp".to_owned(),
        }
    },

    "!" <BaseExpr> => {
        ast::Expression::Unary {
            operator: ast::UnaryOperator::Not,
            rhs: Box::new(<>),
            ty: "temp".to_owned(),
        }
    },
}

#[inline]
CastOp: ast::BinaryOperator = {
    "." => ast::BinaryOperator::Member,
    "as" => ast::BinaryOperator::Cast,
}

#[inline]
AssignmentOperator: ast::AssignmentOperator = {
    "=" => ast::AssignmentOperator::Assign,
    "+=" => ast::AssignmentOperator::AddAssign,
    "-=" => ast::AssignmentOperator::SubtractAssign,
    "*=" => ast::AssignmentOperator::MultiplyAssign,
    "/=" => ast::AssignmentOperator::DivideAssign,
}

#[inline]
MultOp: ast::BinaryOperator = {
    "*" => ast::BinaryOperator::Multiply,
    "/" => ast::BinaryOperator::Divide,
}

#[inline]
AddOp: ast::BinaryOperator = {
    "+" => ast::BinaryOperator::Plus,
    "-" => ast::BinaryOperator::Minus,
}

#[inline]
BoolOp: ast::BinaryOperator = {
    "==" => ast::BinaryOperator::EqualTo,
    "!=" => ast::BinaryOperator::NotEqualTo,
    ">=" => ast::BinaryOperator::GreaterThanOrEqualTo,
    "<=" => ast::BinaryOperator::LessThanOrEqualTo,
    ">" => ast::BinaryOperator::GreaterThan,
    "<" => ast::BinaryOperator::LessThan,
    "&&" => ast::BinaryOperator::And,
    "||" => ast::BinaryOperator::Or,
}

// ---------------- IDENTIFIER, LITERAL, TAG ----------------

Ident: String = {
    <VEC_IDENTIFIER> => <>.to_owned(),

    <r"[_a-zA-Z]+[_a-zA-Z0-9]*"> => {
        if <>.len() >= 3 && <>[0..=2].to_owned() == "gl_".to_owned() {
            exit_with_message(format!("Error: The identifier prefix 'gl_' is reserved (used in '{}')", <>));
        } 
        
        // TODO: Reserve "__ident__..." for code generation

        <>.to_owned()
    },
}

#[inline]
Tag: ast::Tag = {
    "uniform" => ast::Tag::Uniform,
    "texture2D" => ast::Tag::Texture2D,
    "out" => ast::Tag::Out,
}

Literal: ast::Literal = {
    <Vector> => ast::Literal::Vector(<>),
    <uint:r"[0-9]+"> => ast::Literal::UInt(uint.parse::<u32>().unwrap()),
    <float:r"[0-9]+[.][0-9]*"> => ast::Literal::Float(float.parse::<f32>().unwrap()),
    <boolean:BOOL> => ast::Literal::Bool(boolean.parse::<bool>().unwrap()),
}

Vector: ast::Vector = {
    "vec2" "(" <i1:IdentOrLiteral> "," <i2:IdentOrLiteral> ")"
        => ast::Vector::Vec2(i1, i2),

    "vec3" "(" <i1:IdentOrLiteral> "," <i2:IdentOrLiteral> "," <i3:IdentOrLiteral>
        => ast::Vector::Vec3(i1, i2, i3),

    "vec4" "(" <i1:IdentOrLiteral> "," <i2:IdentOrLiteral> "," <i3:IdentOrLiteral> "," <i4:IdentOrLiteral> ")" 
        => ast::Vector::Vec4(i1, i2, i3, i4),
}

#[inline]
IdentOrLiteral: ast::IdentOrLiteral = {
    Ident => ast::IdentOrLiteral::Ident(<>),
    Literal => ast::IdentOrLiteral::Literal(Box::new(<>)),
}