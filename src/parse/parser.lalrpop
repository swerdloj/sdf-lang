use crate::parse::{context::Context, ast};
use crate::exit_with_message;

grammar(context: &mut Context);


match {
    // Do not allow "true" or "false" as identifiers. Make them literals.
    r"(true)|(false)" => BOOL,

    // Ignore comments
    // from https://github.com/lalrpop/lalrpop/pull/509/commits/ee2f7060e99f902620ac4edeea5cfe3c3551f09c)
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { },
    // TODO: Look at this regex; it may do more than I want 
    // FIXME: Inline comments don't work
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
} else {
    _
}


// ---------------- AST ----------------

// This is the root of the AST (initial grammar symbol)
pub AST: ast::AST = {
    Item* => <>,
}

// TODO: Allow global let statements
// An AST is composed of Items
Item: ast::Item = {
    Function => <>,
    Scene => <>,
    Struct => <>,
}

// ---------------- SCENE ----------------

Scene: ast::Item = {
    "scene" <name:Ident> <s:StatementBlock> => ast::Item::Scene{name: name, statements: s},
}

// ---------------- FUNCTION ----------------

Function: ast::Item = {
    "fn" <name:Ident> <params:FunctionParams> <return_type:("->" <Ident>)?> <s:StatementBlock> 
    => {
        // TODO: Ensure that return statement has same type as function
        // TODO: Ensure that typed functions *have* a return statement

        let ret = if let Some(ty) = return_type {
            ty 
        } else {
            "void".to_owned()
        };

        context.declare_function(name.clone(), params.clone(), ret.clone());

        // context.scopes.pop_scope();

        ast::Item::Function {
            name,
            parameters: params,
            return_type: ret,
            statements: s,
        }
    },
}

#[inline]
FunctionParams: Vec<(String, String)> = {
    "(" <multi:(<Ident> ":" <Ident> ",")*> 
        <single:(<Ident> ":" <Ident>)?> ")" 
    => {
        let mut params = multi;
        
        if let Some(param) = single {
            params.push(param);
        }

        params
    },
}

// ---------------- STRUCT ----------------

Struct: ast::Item = {
    "struct" <name:Ident> "{" <fields:(StructFields)> "}" => {
        context.declare_struct(name.clone(), fields.clone());
        
        ast::Item::Struct {
            name,
            fields,
        }
    },
}

#[inline]
StructFields: Vec<(String, String, Option<ast::Expression>)> = {
    <multi:(<Ident> ":" <Ident> <("=" <Expression>)?> ",")*> 
    <single:(<Ident> ":" <Ident> <("=" <Expression>)?>)?> => {
        let mut fields = multi;
        
        if let Some(field) = single {
            fields.push(field);
        }

        fields
    }
}

// ---------------- STATEMENT ----------------

Statement: ast::Statement = {
    LetStatement => <>,
    
    // TODO: Type check with owning function
    "return" <expr:(Expression)?> ";" => {
        ast::Statement::Return {
            expression: expr,
        }
    },

    AssignmentStatement => <>,

    <Expression> ";" => ast::Statement::Expression(<>),
}

StatementBlock: Vec<ast::Statement> = {
    "{" <statements:(Statement)*> "}" => {
        // TODO: This doesn't account for scopes properly because it is called *after*
        //          variables are declared
        // TODO: Also, don't know where to pop the scope for same reason
        context.scopes.push_scope();

        statements
    },
}

AssignmentStatement: ast::Statement = {
    <id:Ident> <op:AssignmentOperator> <expr:Expression> ";" => {
        if !context.scopes.is_var_in_scope(&id) {
            exit_with_message(format!("Error: No such variable in scope: '{}'", &id));
        }
        
        let expr_type = context.expression_type(&expr);
        if !Context::castable(&expr_type, &context.scopes.var_type(&id)) {
            exit_with_message(format!("Error: Variable '{}' cannot be assigned to incompatible type '{}'", &id, &expr_type));
        }

        ast::Statement::Assignment {
            ident: id,
            op,
            expression: expr,
        }
    }
}
    
LetStatement: ast::Statement = {
    <tag:("@" <Tag>)?>
    "let" <id:Ident> <ty: (":" <Ident>)?> <expr:("=" <Expression>)?> ";" => {              
        // Tagged variables must have specified type and initial value
        if let Some(ref t) = tag {
            if ty.is_none() {
                exit_with_message(format!("Semantic Error: Variable '{}' was tagged as '{:?}', but its type was not specified", id, t));
                unreachable!();
            }

            if expr.is_none() {
                exit_with_message(format!("Semantic Error: Variable '{}' was tagged as '{:?}', but not initialized", id, t));
                unreachable!();
            }

            match t {
                ast::Tag::Uniform => {
                    context.declare_uniform(id.clone(), ty.clone().unwrap());
                }

                _ => {
                    unimplemented!();
                }
            }
        }

        // Hack because 'ty' is immutable
        let checked_type = if let Some(specified_type) = ty {
            // Check whether type assigned is compatible with user-specified
            if let Some(assignment) = &expr {
                let assigned_type = context.expression_type(assignment);
                if !Context::castable(&assigned_type, &specified_type) {
                    exit_with_message(format!("Error: Variable '{}' was declared as a '{}', but assigned to an incompatible type: '{}'",
                                               &id, &specified_type, &assigned_type));
                    unreachable!();
                }
            }
            Some(specified_type)
        } else {
            // Make sure inferred type is valid (not void like a void function call)
            if let Some(assignment) = &expr {
                let expr_type = context.expression_type(&assignment);
                if expr_type != "void" {
                    Some(expr_type)
                } else {
                    exit_with_message(format!("Error: Variable '{}' was assigned type 'void'.", &id));
                    unreachable!();
                }
            } else {
                None
            }
        };

        context.scopes.add_var_to_scope(id.clone(), checked_type.clone().unwrap());

        ast::Statement::Let {
            ident: id.to_owned(),
            tag,
            ty: checked_type,
            expression: expr,
        }
    },

    // let identifier: type { param1: value1, param2: value2, ...};
    "let" <id:Ident> ":" <ty:Ident> "{" <fields:(ConstructorArgs)> "}" ";" => {
        context.scopes.add_var_to_scope(id.clone(), ty.clone());
        
        // Fields are properly ordered and defaults are filled in here
        ast::Statement::LetConstructor {
            ident: id.to_owned(),
            constructor: ast::Constructor {
                ty: ty.clone(),
                fields: context.generate_constructor(&ty, fields),
            },
        }
    },
}

ConstructorArgs: Vec<(String, ast::Expression)> = {
    <multi:(<Ident> ":" <Expression> ",")*>
    <single:(<Ident> ":" <Expression>)?> => {
        let mut args = multi;
        
        if let Some(arg) = single {
            args.push(arg);
        }

        args
    },
}

// ---------------- EXPRESSION ----------------

// TODO: Understand how precedence works
Expression: ast::Expression = {
    BooleanExpr => <>,
}

// Treated same as identifier/literal
FunctionCall: ast::Expression = {
    <name:Ident> "(" <params_multi:(<Expression> ",")*>
                     <param_final:(<Expression>)?> ")"
    => {
        let mut params = params_multi;
        if let Some(param) = param_final {
            params.push(param);
        }

        let ty = context.check_function_call(
            &name, 
            params.iter().map(|expr| context.expression_type(&expr)).collect()
        );

        ast::Expression::FunctionCall {
            name,
            parameters: params,
            ty,
        }
    }
}

// Fourth precedence - left associativity
// Note that `BooleanExpr`s are always of type "bool" 
BooleanExpr: ast::Expression = {
    <lhs:BooleanExpr> <op:BoolOp> <rhs:AdditiveExpr> => ast::Expression::Binary {
        lhs: Box::new(lhs),
        operator: op,
        rhs: Box::new(rhs),
        ty: "bool".to_owned(),
    },

    AdditiveExpr => <>,
}

// Third precedence - left associativity
AdditiveExpr: ast::Expression = {
    <lhs:AdditiveExpr> <op:AddOp> <rhs:MultiplicativeExpr> => {
        let ty = context.add_type(
            &context.expression_type(&lhs), &context.expression_type(&rhs)
        );

        ast::Expression::Binary {
            lhs: Box::new(lhs),
            operator: op,
            rhs: Box::new(rhs),
            ty,
        }
    },

    MultiplicativeExpr => <>,
}

// Second precedence - left associativity
MultiplicativeExpr: ast::Expression = {
    <lhs:MultiplicativeExpr> <op:MultOp> <rhs:BaseExpr> => {
        let ty = context.multiply_type(
            &context.expression_type(&lhs), &context.expression_type(&rhs)
        );

        ast::Expression::Binary {
            lhs: Box::new(lhs),
            operator: op,
            rhs: Box::new(rhs),
            ty,
        }
    },

    BaseExpr => <>,
}

// First precedence - right associativity (for unary ops)
BaseExpr: ast::Expression = {
    "(" <Expression> ")" => <>,

    Literal => ast::Expression::Literal(<>),

    Ident => {
        ast::Expression::Identifier(<>)
    },

    FunctionCall => <>,

    "-" <BaseExpr> => {
        let ty = context.expression_type(&<>);

        ast::Expression::Unary {
            operator: ast::UnaryOperator::Negate,
            rhs: Box::new(<>),
            ty: context.negate_type(&ty),
        }
    },

    "!" <BaseExpr> => {
        let ty = context.expression_type(&<>);

        // The "!" operator works only on bools
        if ty != "bool" {
            exit_with_message(format!("The binary not cannot be used on type '{}'", &ty));
        }

        ast::Expression::Unary {
            operator: ast::UnaryOperator::Not,
            rhs: Box::new(<>),
            ty,
        }
    },
}

#[inline]
AssignmentOperator: ast::AssignmentOperator = {
    "=" => ast::AssignmentOperator::Assign,
    "+=" => ast::AssignmentOperator::AddAssign,
    "-=" => ast::AssignmentOperator::SubtractAssign,
    "*=" => ast::AssignmentOperator::MultiplyAssign,
    "/=" => ast::AssignmentOperator::DivideAssign,
}

#[inline]
MultOp: ast::BinaryOperator = {
    // "as" => ast::BinaryOperator::AsCast,
    "*" => ast::BinaryOperator::Multiply,
    "/" => ast::BinaryOperator::Divide,
}

#[inline]
AddOp: ast::BinaryOperator = {
    "+" => ast::BinaryOperator::Plus,
    "-" => ast::BinaryOperator::Minus,
}

#[inline]
BoolOp: ast::BinaryOperator = {
    "==" => ast::BinaryOperator::EqualTo,
    "!=" => ast::BinaryOperator::NotEqualTo,
    ">=" => ast::BinaryOperator::GreaterThanOrEqualTo,
    "<=" => ast::BinaryOperator::LessThanOrEqualTo,
    ">" => ast::BinaryOperator::GreaterThan,
    "<" => ast::BinaryOperator::LessThan,
    "&&" => ast::BinaryOperator::And,
    "||" => ast::BinaryOperator::Or,
}

// ---------------- IDENTIFIER, LITERAL, TAG ----------------

Ident: String = {
    <r"[_a-zA-Z]+[_a-zA-Z0-9]*"> => <>.to_owned(),
}

#[inline]
Tag: ast::Tag = {
    "uniform" => ast::Tag::Uniform,
    "texture2D" => ast::Tag::Texture2D,
    "out" => ast::Tag::Out,
}

Literal: ast::Literal = {
    <uint:r"[0-9]+"> => ast::Literal::UInt(uint.parse::<u32>().unwrap()),
    <float:r"[0-9]+[.][0-9]*"> => ast::Literal::Float(float.parse::<f32>().unwrap()),
    <boolean:BOOL> => ast::Literal::Bool(boolean.parse::<bool>().unwrap()),
}